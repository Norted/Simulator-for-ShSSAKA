#include <AKA_OLD.h>

struct aka_Keychain g_serverKeys;
struct aka_Keychain g_aka_clientKeys;

/* Generate spar = (G, g, q) from session key kappa → GENERATED BY CIPHER SUITE
    int aka_Setup (int kappa) {

        return 0;
    }
*/

/* Generate pk_c and sk_c from session key kappa → GENERATED BY CIPHER SUITE
    int aka_ClientRegister (int kappa) {

        return 0;
    }
*/

unsigned int aka_setup()
{
    int i = 0;
    
    printf("---SERVER---\n");
    init_aka_mem(&g_serverKeys);
    if (!g_serverKeys.ID || !g_serverKeys.keys->pk || !g_serverKeys.keys->sk)
    {
        printf(" * AKA server key initialization failed! (AKA, aka_setup)\n");
        return 0;
    }
    aka_keyPrinter(&g_serverKeys);

    printf("\n---CLIENT---\n");
    init_aka_mem(&g_aka_clientKeys);
    if (!g_aka_clientKeys.ID || !g_aka_clientKeys.keys->pk || !g_aka_clientKeys.keys->sk)
    {
        printf(" * AKA client key initialization failed! (AKA, aka_setup)\n");
        return 0;
    }
    aka_keyPrinter(&g_aka_clientKeys);

    printf("\n");

    return 1;
}

unsigned int aka_serverSignVerify(BIGNUM *Y, struct ServerSign *server)
{
    unsigned int err = 0;

    if (BN_is_zero(Y) == 1 || BN_is_zero(g_serverKeys.keys->sk) == 1 || BN_is_zero(g_aka_clientKeys.keys->pk) == 1)
    {
        BN_dec2bn(&server->tau_s, "0");
        printf("Y, SERVER sk or CLIENT pk == 0!\n");
        return 0;
    }

    unsigned char *ver = malloc(sizeof(char*) * BUFFER);
    struct ClientProof client;
    struct schnorr_Signature signature;
    /* signature = malloc(sizeof(struct schnorr_Signature));
    if (signature == NULL)
    {
        printf(" * SIGNATURE ALOCATION FAILED!\n");
        goto end;
    } */
    init_clientproof(&client);
    init_schnorr_signature(&signature);

    err = schnorr_sign(g_globals.params, g_serverKeys.keys->sk, Y, server->kappa, &signature);
    if (err != 1)
    {
        printf(" * Schnorr's signature failed! (AKA, aka_serverSignVerify)\n");
        goto end;
    }

    /*
     *  Server  →   (Y, sigma)      →   Client
     *         (aka_clientProofVerify)
     *  Server  ←   (tau_c, kappa)  ←   Client
     */
    err = aka_clientProofVerify(Y, &signature, &client);
    if (err != 1 || BN_is_zero(client.tau_c) == 1)
    {
        BN_dec2bn(&server->tau_s, "0");
        printf(" * Client Proof Verify failed! (AKA, aka_serverSignVerify)\n");
        goto end;
    }

    BN_copy(client.signature->r, signature.r);
    BN_dec2bn(&server->kappa, "1");
    sprintf(ver, "%d", schnorr_verify(g_globals.params, g_aka_clientKeys.keys->pk, Y, server->kappa, client.signature));
    BN_dec2bn(&server->tau_s, ver);

    //printf("** S_KAPPA: %s\n** C_KAPPA: %s\n", BN_bn2dec(server->kappa), BN_bn2dec(client.kappa));
    if (BN_cmp(server->kappa, client.kappa) == 0)
        printf("\n~ GOOD! :)\n\n");

end:
    free_clientproof(&client);
    free_schnorr_signature(&signature);
    free(ver);
    return err;
}

unsigned int aka_clientProofVerify(BIGNUM *Y, struct schnorr_Signature *server_signature, struct ClientProof *client)
{
    unsigned int err = 0;
    unsigned char *ver = malloc(sizeof(char*) * BUFFER);
    BIGNUM * zero = BN_new();
    BN_dec2bn(&zero, "0");

    sprintf(ver, "%d", schnorr_verify(g_globals.params, g_serverKeys.keys->pk, Y, zero, server_signature));
    BN_dec2bn(&client->tau_c, ver);

    if (BN_is_zero(client->tau_c) == 1)
    {
        printf(" * Schnorr's signature verification failed! (AKA, aka_clientProofVerify)\n");
        goto end;
    }

    BN_dec2bn(&client->kappa, "1");
    BN_copy(client->signature->c_prime, server_signature->c_prime);
    err = schnorr_sign(g_globals.params, g_aka_clientKeys.keys->sk, Y, client->kappa, client->signature);
    if (err != 1)
    {
        printf(" * Client proof verification failed! (AKA, aka_clientProofVerify)\n");
        goto end;
    }

end:
    free(ver);
    BN_free(zero);
    return err;
}

void init_aka_mem(struct aka_Keychain *keychain)
{
    keychain->ID = g_globals.idCounter++;
    keychain->keys = (struct schnorr_Keychain *)malloc(sizeof(struct schnorr_Keychain));
    init_schnorr_keychain(keychain->keys);
    gen_schnorr_keys(dsa, keychain->keys);
    return;
}

void free_aka_mem(struct aka_Keychain *keychain)
{
    //keychain->ID = NULL;
    free_schnorr_keychain(keychain->keys);
    free(keychain->keys);
    return;
}

/*  Support function definition
 *  print to console the keychain variables
 */

void aka_keyPrinter(struct aka_Keychain *key)
{
    printf("ID: %d\n", key->ID);
    printf("PK: %s\n", BN_bn2dec(key->keys->pk)); // FAILS -- not allocated???
    printf("SK: %s\n", BN_bn2dec(key->keys->sk));

    return;
}