#include <AKA.h>

// definition of global values
struct aka_Keychain g_aka_serverKeys;
struct aka_Keychain g_aka_clientKeys;
struct aka_Keychain g_aka_devicesKeys[G_NUMOFDEVICES];

// supportive functions declarations
void _aka_keyPrinter(struct aka_Keychain *key);


/* Generate spar = (G, g, q) from session key kappa → GENERATED BY CIPHER SUITE
    int aka_Setup (int kappa) {
        
        return 0;
    }
*/

/* Generate pk_c and sk_c from session key kappa → GENERATED BY CIPHER SUITE
    int aka_ClientRegister (int kappa) {
        
        return 0;
    }
*/

unsigned int aka_setup() {
    unsigned int err = 0;
    int i = 0;

    if(g_globals.g_idCounter != 1)
        init_g_global();
    //sprintf(g_g, "%u", rand() % G_GENERATORSLEN); // g_generators[0]

    printf("---SERVER---\n");
    err += aka_initKeys(&g_aka_serverKeys);

    printf("\n---CLIENT---\n");
    err += aka_initKeys(&g_aka_clientKeys);

    printf("\n---DEVICES---\n");
    for (i = 0; i < G_NUMOFDEVICES; i++) {
        printf("\n- DEVICE %d -\n", i+1);
        err += aka_initKeys(&g_aka_devicesKeys[i]);
    }
    printf("\n");

    if(err != (2 + G_NUMOFDEVICES))
        return 0;

    return 1;
}

// initialize the keychain with computed values
unsigned int aka_initKeys(struct aka_Keychain *keys) {
    unsigned int err = 0;
    unsigned char *rnd = malloc(sizeof(unsigned int));
    err += random_str_num_in_range(rnd, G_MAXRANDOMNUMBER, G_MINRANDOMNUMBER);
    err += bn_mod(rnd, g_globals.g_q, keys->sk);

    if(bn_cmp(keys->sk, "2") == -1) {
        err -= 1;
        err += bn_mod(rnd, g_globals.g_q, keys->sk);
    }
    

    err += bn_exp(g_globals.g_g, keys->sk, keys->pk);
    sprintf(keys->ID, "%u", g_globals.g_idCounter++);
    
    _aka_keyPrinter(keys);
    
    if(err != 3)
        return 0;
    
    return 1;
}

unsigned int aka_serverSignVerify (unsigned char * Y, unsigned char * pk_c, unsigned char * sk_s, struct ServerSign *server) {
    unsigned int err = 0;
    struct ClientProof client ={{""}};

    if (strncmp(Y, "0", sizeof(Y)) == 0 || strncmp(sk_s, "0", sizeof(Y)) == 0 || strncmp(pk_c, "0", sizeof(Y)) == 0) {
        strcpy(server->tau_s, "0");
        printf("Y, sk_s or pk_c == 0!\n");
        return 0;
    }

    unsigned char r_s[BUFFER];
    unsigned char t_s[BUFFER];

    unsigned char *rnd = malloc(sizeof(unsigned int));
    err += random_str_num_in_range(rnd, G_MAXRANDOMNUMBER, G_MINRANDOMNUMBER);
    err += bn_mod(rnd, g_globals.g_q, r_s);
    err += bn_modexp(g_globals.g_g, r_s, g_globals.g_q, t_s);  //t_s 

    free(rnd);

    unsigned char e_s[BUFFER];
    unsigned char s_s[BUFFER];
    err += hash(e_s, Y, t_s, "0");
    
    unsigned char mul[BUFFER];
    err += bn_modmul(e_s, sk_s, g_globals.g_q, mul);
    unsigned char sub[BUFFER];
    err += bn_sub("0", mul, mul);
    err += bn_add(r_s, mul, sub);
    err += bn_mod(sub, g_globals.g_q, s_s);

    /*  
     *  Server  →   (Y, sigma)      →   Client
     *         (aka_clientProofVerify)
     *  Server  ←   (tau_c, kappa)  ←   Client
     */
    err += aka_clientProofVerify(Y, e_s, s_s, &g_aka_serverKeys.pk, &g_aka_clientKeys.sk, &client);
    if(strcmp(client.tau_c, "0") == 0) {
        strcpy(server->tau_s, "0");
        return 0;
    }

    unsigned char t_chck_1[BUFFER];
    err += bn_modexp(g_globals.g_g, client.pi[1], g_globals.g_q, t_chck_1);
    unsigned char t_chck_2[BIG_BUFFER];
    err += bn_modexp(pk_c, client.pi[0], g_globals.g_q, t_chck_2);
    unsigned char t_chck[BIG_BUFFER];
    err += bn_modmul(t_chck_1, t_chck_2, g_globals.g_q, t_chck);
    err += bn_modexp(t_chck, r_s, g_globals.g_q, server->kappa);
    
    unsigned char digest[BUFFER];
    err += hash(digest, Y, t_chck, server->kappa);

    if (strcmp(client.pi[0], digest) == 0) {
        strcpy(server->tau_s, "1");
    }
    else {
        strcpy(server->tau_s, "0");
    }

    if (err != 14)
        return 0;
    return 1;
}

unsigned int aka_clientProofVerify (unsigned char *Y, unsigned char *e_s, unsigned char *s_s, unsigned char *pk_s, unsigned char *sk_c, struct ClientProof *client) {
    unsigned int err = 0;
    unsigned char t_s_chck_1[BUFFER];
    err += bn_modexp(g_globals.g_g, s_s, g_globals.g_q, t_s_chck_1);
    unsigned char t_s_chck_2[BUFFER];
    err += bn_modexp(pk_s, e_s, g_globals.g_q, t_s_chck_2);
    unsigned char t_s_chck[BUFFER];
    err += bn_modmul(t_s_chck_1, t_s_chck_2, g_globals.g_q, t_s_chck);
    
    unsigned char digest[BUFFER];
    err += hash(digest, Y, t_s_chck, "0");

    if (strcmp(e_s, digest) == 0) {
        strcpy(client->tau_c, "1");
    }
    else {
        strcpy(client->tau_c, "0");
        return 0;
    }

    unsigned char r_c[BUFFER];
    unsigned char *rnd = malloc(sizeof(unsigned int));
    err += random_str_num_in_range(rnd, G_MAXRANDOMNUMBER, G_MINRANDOMNUMBER);
    err += bn_mod(rnd, g_globals.g_q, r_c);
    free(rnd);

    unsigned char t[BUFFER];
    err += bn_modexp(g_globals.g_g, r_c, g_globals.g_q, t);

    err += bn_modexp(t_s_chck, r_c, g_globals.g_q, client->kappa);
    err += hash(client->pi[0], Y, t, client->kappa);    //e_c

    unsigned char mul[BUFFER];
    err += bn_modmul(client->pi[0], sk_c, g_globals.g_q, mul);
    unsigned char sub[BUFFER];
    err += bn_sub("0", mul, mul);
    err += bn_add(r_c, mul, sub);
    err += bn_mod(sub, g_globals.g_q, client->pi[1]);             //s_c

    if(err != 13)
        return 0;
    return 1;
}

/*  Support function definition
 *  print to console the keychain variables
 */

void _aka_keyPrinter(struct aka_Keychain *key) {
    printf("ID: %s\n", key->ID);
    printf("PK: %s\n", key->pk);
    printf("SK: %s\n", key->sk);
    
    return;
}