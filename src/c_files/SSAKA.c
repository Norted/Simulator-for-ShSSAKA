#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <limits.h>
// extern headers
#include <polynomial.h>
#include <gcrypt.h>
#include <SSAKA.h>


// definition of global values
const unsigned int g_q = 18;
unsigned int g_g;
const unsigned int g_generators[6] = {4, 7, 9, 10, 13, 16};
unsigned int g_idCounter = 1;

const int g_generatorsLen = 5;
const int g_maxRandomNumber = 100;
const int g_minRandomNumber = 1;

struct Keychain g_clientKeys;
struct Keychain g_serverKeys;
struct Keychain g_devicesKeys[G_NUMOFDEVICES];


// supportive functions declarations
unsigned int _hash(unsigned int Y, unsigned int sigma, unsigned int kappa);
void _keyPrinter(struct Keychain keys);
struct Keychain _initKeys();



/* Generate spar = (G, g, q) from session key kappa → GENERATED BY CIPHER SUITE
    int aka_Setup (int kappa) {
        
        return 0;
    }
*/

/* Generate pk_c and sk_c from session key kappa → GENERATED BY CIPHER SUITE
    int aka_ClientRegister (int kappa) {
        
        return 0;
    }
*/

void setup() {
    g_g = g_generators[rand() % g_generatorsLen];

    printf("---SERVER---\n");
    g_serverKeys = _initKeys();
    
    printf("\n---CLIENT---\n");
    g_clientKeys = _initKeys();
    
    printf("\n---DEVICE---\n");
    for (int i = 0; i < G_NUMOFDEVICES; i++) {
        printf("\n- DEVICE %d -\n", i);
        g_devicesKeys[i] = _initKeys();
    }
    printf("\n");

    return;
}

/*  AKA
 *  /////////////////////////////////////////////////////////
 *  //   aaaa   kk   kk    aaaa   ///////////////////////////
 *  //  aa  aa  kk  kk    aa  aa  ///////////////////////////
 *  //  aaaaaa  kkkk      aaaaaa  ///////////////////////////
 *  //  aa  aa  kk  kk    aa  aa  ///////////////////////////
 *  //  aa  aa  kk    kk  aa  aa  ///////////////////////////
 *  /////////////////////////////////////////////////////////
 */

struct ServerSign aka_serverSignVerify (unsigned int Y, unsigned int sk_s, unsigned int pk_c) {
    unsigned int sigma[2];
    struct ServerSign server;
    struct ClientProof client;

    if (Y == 0 || sk_s == 0 || pk_c == 0) {
        server.tau_s = 0;
        printf("Y, sk_s or pk_c == 0!\n");
        return server;
    }

    unsigned int r_s = (rand() % (g_maxRandomNumber + 1 - g_minRandomNumber) + g_minRandomNumber)%g_q;
    unsigned int t_s = (unsigned int) pow((double) g_g, (double) r_s);
    
    sigma[0] = _hash(Y, t_s, 0U);        //e_s
    sigma[1] = (r_s - sigma[0]*sk_s)%g_q; //s_s
    
    /*  
     *  Server  →   (Y, sigma)      →   Client
     *         (aka_clientProofVerify)
     *  Server  ←   (tau_c, kappa)  ←   Client
     */
    client = aka_clientProofVerify(Y, sigma, g_serverKeys.pk, g_clientKeys.sk);

    unsigned int t_chck = (unsigned int) pow((double) g_g, (double) client.pi[1]) * pow((double) pk_c, (double) client.pi[0]);
    server.kappa = (unsigned int) pow((double) t_chck, (double) r_s);
    
    if (client.pi[0] == _hash(Y, t_chck, server.kappa)) {
        server.tau_s = 1;
    }
    else {
        server.tau_s = 0;
    }
     
    return server;
}

struct ClientProof aka_clientProofVerify (unsigned int Y, unsigned int sigma[2], unsigned int pk_s, unsigned int sk_c) {
    struct ClientProof client;
    unsigned int t_s_chck = (unsigned int) pow((double) g_g, (double) sigma[1]) * (unsigned int) pow((double) pk_s, (double) sigma[0]);
    
    if (sigma[0] == _hash(Y, t_s_chck, 0U)) {
        client.tau_c = 1;
    }
    else {
        client.tau_c = 0;
        return client;
    }

    unsigned int r_c = (rand() % (g_maxRandomNumber + 1 - g_minRandomNumber) + g_minRandomNumber)%g_q;
    unsigned int t = (unsigned int) pow((double) g_g, (double) r_c);

    client.kappa = (unsigned int) pow((double) t_s_chck, (double) r_c);
    client.pi[0] = _hash(Y, t, client.kappa);        //e_c
    client.pi[1] = (r_c - client.pi[0] * sk_c)%g_q;   //s_c

    return client;
}

/*  SSAKA
 *  /////////////////////////////////////////////////////////
 *  //  ssssss  ssssss   aaaa   kk   kk    aaaa   ///////////
 *  //  ss      ss      aa  aa  kk  kk    aa  aa  ///////////
 *  //  ssssss  ssssss  aaaaaa  kkkk      aaaaaa  ///////////
 *  //      ss      ss  aa  aa  kk  kk    aa  aa  ///////////
 *  //  ssssss  ssssss  aa  aa  kk    kk  aa  aa  ///////////
 *  /////////////////////////////////////////////////////////
 */

struct Share ssaka_ClientAddShare(unsigned int sk_new[][2], unsigned int sk_c, unsigned int pk_c) {
    struct Share share;

    unsigned int poly_degree = 2;
    unsigned int poly_coefs[3] = {0, 0, 0};
    Polynomial *poly = polynomial_new(poly_degree);
    for (int i = 0; i < poly_degree; i++) {
        poly_coefs[0] += sk_new[i][1];
        poly_coefs[1] += sk_new[i][0] % 2;
        poly_coefs[2] += sk_new[i][0] - (sk_new[i][0] % 2);
    }
    
    for (int i = 0; i <= poly_degree; i++) {
        polynomial_set_coefficient(poly, i, poly_coefs[i]);
    }

    int size = sizeof(sk_new) / sizeof(sk_new[0]);
    for (int i = 0; i < size; i++) {
        // TODO
        share.pk_c = 0;
        share.pk_c_dash = 0;
        share.sk_c = 0;
    }
    return share;
}

struct Share ssaka_ClientRevShare(unsigned int sk_rev[][2], unsigned int sk_c, unsigned int pk_c) {
    struct Share share;
    
    int size = sizeof(sk_rev) / sizeof(sk_rev[0]);
    for (int i = 0; i < size; i++) {
        // TODO
        share.pk_c = 0;
        share.pk_c_dash = 0;
        share.sk_c = 0;
    }
    return share;
}

struct ClientProof ssaka_ClientProofVerify(unsigned int Y, unsigned int sigma[2], unsigned int pk_s, unsigned int sk_c) {
    struct ClientProof client;
    unsigned int t_s_chck = (unsigned int) pow((double) g_g, (double) sigma[1]) * (unsigned int) pow((double) pk_s, (double) sigma[0]);
    
    if (sigma[0] == _hash(Y, t_s_chck, 0U)) {
        client.tau_c = 1;
    }
    else {
        client.tau_c = 0;
        return client;
    }

    /*  t_s_chck, sk_i  →   SSAKA-DEVICE-PROOFVERIFY(t_s_chck, sk_i)
     *
     *  +++++++++++++++++++++
     *  ++++ DEVICE SIDE ++++
     *  +++++++++++++++++++++
     */

    struct DeviceProof devices[G_NUMOFDEVICES];
    unsigned int t_i[G_NUMOFDEVICES];
    unsigned int r_i[G_NUMOFDEVICES];
    for (int i = 0; i < G_NUMOFDEVICES; i++) {
        r_i[i] = (rand() % (g_maxRandomNumber + 1 - g_minRandomNumber) + g_minRandomNumber)%g_q;
        t_i[i] = (unsigned int) pow((double) g_g, (double) r_i[i]);
        devices[i].kappa_i = (unsigned int) pow((double) t_s_chck, (double) r_i[i]);
    }

    /*                  ←   <kappa_i, t_i>
     *
     *  +++++++++++++++++++++
     *  ++++ CLIENT SIDE ++++
     *  +++++++++++++++++++++
     */
    unsigned int r_0 = (rand() % (g_maxRandomNumber + 1 - g_minRandomNumber) + g_minRandomNumber)%g_q;
    unsigned int t = (unsigned int) pow((double) g_g, (double) r_0);
    client.kappa = (unsigned int) pow((double) t_s_chck, (double) r_0);
    for (int i = 0; i < G_NUMOFDEVICES; i++) {
        t *= t_i[i];
        client.kappa *= devices[i].kappa_i;
    }
    client.pi[0] = _hash(Y, t, client.kappa);         //e_c

    /*  e_c             →   SSAKA-DEVICE-PROOFVERIFY
     *
     *  +++++++++++++++++++++
     *  ++++ DEVICE SIDE ++++
     *  +++++++++++++++++++++
     */
    for (int i = 0; i < G_NUMOFDEVICES; i++) {
        devices[i].s_i = (r_i[i] - client.pi[0] * g_devicesKeys[i].sk)%g_q;
    }

    /*                  ←   <device_i>
     *
     *  +++++++++++++++++++++
     *  ++++ CLIENT SIDE ++++
     *  +++++++++++++++++++++
     */
    unsigned int s_0 = (r_0 - client.pi[0] * g_clientKeys.sk)%g_q;
    client.pi[1] = s_0;
    for (int i = 0; i < G_NUMOFDEVICES; i++) {
        client.pi[1] += devices[i].s_i;
    }
    client.pi[1] %= g_q;

    return client;
}

/*  Support function definition
 *  /////////////////////////////////////////////////////////
 *  //                                   ////////////////////
 *  //  DEFINITION OF SUPPORT FUNCTIONS  ////////////////////
 *  //                                   ////////////////////
 *  /////////////////////////////////////////////////////////
 */

// print to console the keychain variables
void _keyPrinter(struct Keychain keys) {
    printf("ID: %u\n", keys.ID);
    printf("PK: %u\n", keys.pk);
    printf("SK: %u\n", keys.sk);
    
    return;
}

// initialize the keychain with computed values
struct Keychain _initKeys() {
    struct Keychain keys;
    keys.sk = (unsigned int) (rand() % (g_maxRandomNumber + 1 - g_minRandomNumber) + g_minRandomNumber)%g_q;
    if(keys.sk < 2)
        keys.sk += 2;
    keys.pk = (unsigned int) powl((long double) g_g, (long double) keys.sk);
    keys.ID = g_idCounter++;
    
    _keyPrinter(keys);
    return keys;
}

// momentally used instead of chosen hash from suite
unsigned int _hash(unsigned int Y, unsigned int t_s, unsigned int kappa) {
    /* gcry_md_hd_t * hd;
    gcry_error_t error;
    error = gcry_md_open(hd, GCRY_MD_SHA3_512, GCRY_MD_FLAG_HMAC); */
    return (unsigned int) ((Y * pow(10, (double) log10(t_s)+1) + t_s)*pow(10, (double) log10(kappa)+1))%g_q;
}