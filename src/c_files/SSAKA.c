#include <SSAKA.h>

// definition of global values
//unsigned char g_g[BUFFER];
//unsigned int g_idCounter = 1;

struct aka_Keychain g_ssaka_serverKeys;
struct ssaka_Keychain g_ssaka_deviceKeys[G_NUMOFDEVICES+1];

struct paillierKeychain g_paiKeys = {{""}};

// supportive functions declarations
void _ssaka_keyPrinter(struct ssaka_Keychain *key);

/* Generate spar = (G, g, q) from session key kappa → GENERATED BY CIPHER SUITE
    int aka_Setup (int kappa) {
        
        return 0;
    }
*/

/* Generate pk_c and sk_c from session key kappa → GENERATED BY CIPHER SUITE
    int aka_ClientRegister (int kappa) {
        
        return 0;
    }
*/

unsigned int ssaka_setup() {
    unsigned int err = 0;
    int i = 0;

    err += generate_keypair(&g_paiKeys);

    if(g_globals.g_idCounter != 1)
        init_g_global();
    //sprintf(g_g, "%u", rand() % G_GENERATORSLEN); // g_generators[0]

    printf("---SERVER---\n");
    err += aka_initKeys(&g_ssaka_serverKeys);

    // pre-init of SSAKA keys for client and other devices
    for (i; i <= G_NUMOFDEVICES; i++) {
        err += ssaka_KeyGeneration(&g_ssaka_deviceKeys[i]);
    }
    
    for (i = 0; i <= G_NUMOFDEVICES; i++) {
        err += ssaka_ShamirKeyComputation(g_ssaka_deviceKeys[i].sk, i);
        if(bn_cmp(g_ssaka_deviceKeys[i].sk, "0") == 0) {
            i--;
            err--;
        }
    }

    printf("\n---CLIENT---\n");
    _ssaka_keyPrinter(&g_ssaka_deviceKeys[0]);

    printf("\n---DEVICES---\n");
    for (i = 1; i <= G_NUMOFDEVICES; i++) {
        printf("\n- DEVICE %d -\n", i);
        _ssaka_keyPrinter(&g_ssaka_deviceKeys[i]);
    }
    printf("\n");

    if(err != (2 + (2 * (G_NUMOFDEVICES+1))))
        return 0;

    return 1;
}

unsigned int ssaka_KeyGeneration(struct ssaka_Keychain *ssaka_Keychain) {
    unsigned int err = 0;
    sprintf(ssaka_Keychain->ID, "%u", g_globals.g_idCounter++);
    *ssaka_Keychain->pk = *ssaka_Keychain->ID;
    unsigned char *rnd = malloc(sizeof(unsigned int));
    for(int i = 0; i < G_POLYDEGREE; i++) {
        err += random_str_num(rnd);
        err += bn_mod(rnd, g_globals.g_q, ssaka_Keychain->ds[i]);
    }
    err += random_str_num(rnd);
    err += bn_mod(rnd, g_globals.g_q, ssaka_Keychain->kappa);

    free(rnd);

    if(err != (2 + (2 * G_POLYDEGREE)))
        return 0;
    
    return 1;
}

unsigned int ssaka_ShamirKeyComputation(unsigned char *key, unsigned int device_ID) {
    int i = 0;
    unsigned int counter = 1;
    unsigned int err = 0;

    unsigned char c1[BUFFER];
    err += ssaka_PaillierEncryption(&g_ssaka_deviceKeys[device_ID], c1);

    unsigned char c_prime[BUFFER];
    err += ssaka_PaillierEncryption(&g_ssaka_deviceKeys[(device_ID+(counter++))%G_NUMOFDEVICES], c_prime);
    unsigned char tmp_c[BUFFER];
    for (i; i < G_NUMOFDEVICES-2; i++) {
        ssaka_PaillierEncryption(&g_ssaka_deviceKeys[(device_ID+(counter++))%G_NUMOFDEVICES], tmp_c);
        mul_const(g_paiKeys.pk, c_prime, tmp_c, c_prime);
    }
    err += 2;

    unsigned char dec[BUFFER];
    err += decrypt(&g_paiKeys, c_prime, dec);
    unsigned char added[BUFFER];
    err += add(g_paiKeys.pk, dec, c1, added);
    err += bn_mod(added, g_globals.g_q, key);
    
    if(err != 7)
        return 0;

    return 1;
}

unsigned int ssaka_PaillierEncryption(struct ssaka_Keychain *ssaka_Keychain, unsigned char *ci) {
    unsigned int err = 0;
    int i = 0;

    unsigned char poly_parts[G_POLYDEGREE][BUFFER];
    for (i = 0; i < G_POLYDEGREE; i++) {
        err += encrypt(g_paiKeys.pk, ssaka_Keychain->ds[i], poly_parts[i]);
    }
    unsigned char c_kappa[BUFFER];
    err += encrypt(g_paiKeys.pk, ssaka_Keychain->kappa, c_kappa);
    
    unsigned char alpha[BUFFER];
    unsigned char *exp = malloc(sizeof(unsigned int));
    for(i = 0; i < G_POLYDEGREE; i++) {
        sprintf(exp, "%d", (i+1));
        err += bn_exp(ssaka_Keychain->pk, exp, alpha);
        err += mul_const(g_paiKeys.pk, poly_parts[i], alpha, poly_parts[i]);
    }

    unsigned char ci_prime[BUFFER] = "1";
    for(i = 0; i < (G_POLYDEGREE); i++) {
        err += add(g_paiKeys.pk, ci_prime, poly_parts[i], ci_prime);
    }
    err += add(g_paiKeys.pk, ci_prime, c_kappa, ci);

    if(err != ((4 * G_POLYDEGREE) + 2))
        return 0;
    
    return 1;
}

unsigned int ssaka_interpolation (unsigned char *interpolation, unsigned int device) {
    // https://en.wikipedia.org/wiki/Shamir's_Secret_Sharing
    int i = 0;
    unsigned int err = 0;
    
    unsigned int place = 0;
    unsigned char tmp_mul[BUFFER] = "1";
    unsigned char tmp_inverse[BUFFER];
    //unsigned char rem[BUFFER];
    unsigned char tmp_subs[G_NUMOFDEVICES-1][BUFFER];
    unsigned char div_parts[G_NUMOFDEVICES-1][BUFFER];
    while(err >= (3*G_NUMOFDEVICES)) {
        err = 0;
        place = 0;
        for(i = 0; i < G_NUMOFDEVICES; i++) {
            if(i == device)
                continue;
            err += bn_sub(g_ssaka_deviceKeys[i].pk, g_ssaka_deviceKeys[device].pk, tmp_subs[place]);
            err += bn_modinverse(tmp_subs[place], g_globals.g_q, tmp_inverse);
            err += bn_modmul(g_ssaka_deviceKeys[i].pk, tmp_inverse, g_globals.g_q, div_parts[place]);
            //err += bn_div(g_ssaka_deviceKeys[i].pk, tmp_subs[place], div_parts[place], rem);
            err += bn_modmul(tmp_mul, div_parts[place], g_globals.g_q, tmp_mul);
            place++;
        }
        //printf("INAPP ERR: %u\n", err);
        if(err == 10 || err == 11)
            return 0;
    }

    err += bn_modmul(tmp_mul, g_ssaka_deviceKeys[device].sk, g_globals.g_q, interpolation);

    //printf("INAPP ERR: %u\n", err);
    if(err >= ((3 * G_NUMOFDEVICES) + 1))
        return 0;
    
    return 1;
}

unsigned int ssaka_ClientAddShare(unsigned int new_devices_list[], unsigned int list_size, unsigned char *sk_c, unsigned char *pk_c_old, struct Share *share) {
    unsigned int err = 0;
    unsigned char sk_i[BUFFER];

    strcpy(sk_i, "0");
    strcpy(share->new_sk_c, sk_c);
    strcpy(share->new_pk_c, pk_c_old);

    int i = 0;
    if(list_size <= 3) {
        printf("The nuber of devices must be > 3!\n");
        return 0;
    }

    for (i; i < list_size; i++) {
        err += ssaka_interpolation(sk_i, new_devices_list[i]);
        err += bn_modadd(share->new_sk_c, sk_i, g_globals.g_q, share->new_sk_c);
    }

    for (i = 0; i < list_size; i++) {
        err += bn_mul(share->new_pk_c, g_ssaka_deviceKeys[new_devices_list[i]].pk, share->new_pk_c);
    }

    if(err != (list_size + (2*list_size)))
        return 0;
    
    return 1;
}

/*  SSAKA REVERSE SHARE 

    unsigned int ssaka_ClientRevShare(unsigned int *rev_devices_list, unsigned char *sk_c_old, unsigned char *pk_c_old, struct Share *share) {
        struct Share share;
        
        int size = sizeof(sk_rev) / sizeof(sk_rev[0]);
        for (int i = 0; i < size; i++) {
            // TODO
            share.pk_c = 0;
            share.pk_c_dash = 0;
            share.sk_c = 0;
        }
        return share;
    }
*/


unsigned int ssaka_akaServerSignVerify(unsigned int list_of_used_devs[], unsigned int size, unsigned char * Y, unsigned char * pk_c, unsigned char * sk_s, struct ServerSign *server) {
    unsigned int err = 0;
    struct ClientProof client ={{""}};

    if (strncmp(Y, "0", sizeof(Y)) == 0 || strncmp(sk_s, "0", sizeof(Y)) == 0 || strncmp(pk_c, "0", sizeof(Y)) == 0) {
        strcpy(server->tau_s, "0");
        printf("Y, sk_s or pk_c == 0!\n");
        return 0;
    }

    unsigned char r_s[BUFFER];
    unsigned char t_s[BUFFER];

    unsigned char *rnd = malloc(sizeof(unsigned int));
    err += random_str_num_in_range(rnd, G_MAXRANDOMNUMBER, G_MINRANDOMNUMBER);
    err += bn_mod(rnd, g_globals.g_q, r_s);
    err += bn_modexp(g_globals.g_g, r_s, g_globals.g_q, t_s);  //t_s 

    free(rnd);

    unsigned char e_s[BUFFER];
    unsigned char s_s[BUFFER];
    err += hash(e_s, Y, t_s, "0");
    
    unsigned char mul[BUFFER];
    err += bn_hashmul(e_s, sk_s, mul);
    unsigned char sub[BUFFER];
    err += bn_sub("0", mul, mul);
    err += bn_add(r_s, mul, sub);
    err += bn_mod(sub, g_globals.g_q, s_s);

    /*  
     *  Server  →   (Y, sigma)      →   Client
     *         (aka_clientProofVerify)
     *  Server  ←   (tau_c, kappa)  ←   Client
     */
    err += ssaka_ClientProofVerify(list_of_used_devs, size, Y, e_s, s_s, &g_ssaka_serverKeys.pk, &g_ssaka_deviceKeys[0].sk, &client);
    if(strcmp(client.tau_c, "0") == 0) {
        strcpy(server->tau_s, "0");
        return 0;
    }

    unsigned char t_chck_1[BUFFER];
    err += bn_modexp(g_globals.g_g, client.pi[1], g_globals.g_q, t_chck_1);
    unsigned char t_chck_2[BIG_BUFFER];
    err += bn_hashexp(pk_c, client.pi[0], g_globals.g_q, t_chck_2);
    unsigned char t_chck[BIG_BUFFER];
    err += bn_modmul(t_chck_1, t_chck_2, g_globals.g_q, t_chck);
    err += bn_modexp(t_chck, r_s, g_globals.g_q, server->kappa);
    
    unsigned char digest[BUFFER];
    err += hash(digest, Y, t_chck, server->kappa);

    if (strcmp(client.pi[0], digest) == 0) {
        strcpy(server->tau_s, "1");
    }
    else {
        strcpy(server->tau_s, "0");
    }

    if (err != 14)
        return 0;
    return 1;
}


unsigned int ssaka_ClientProofVerify(unsigned int list_of_used_devs[], unsigned int size, unsigned char *Y, unsigned char *e_s, unsigned char *s_s, unsigned char *pk_s, unsigned char *sk_c, struct ClientProof *client) {
    unsigned int err = 0;
    
    unsigned char pow_1[BUFFER];
    err += bn_modexp(g_globals.g_g, s_s, g_globals.g_q, pow_1);
    unsigned char pow_2[BUFFER];
    err += bn_modexp(pk_s, e_s, g_globals.g_q, pow_2);
    unsigned char t_s_chck[BUFFER];
    err += bn_modmul(pow_1, pow_2, g_globals.g_q, t_s_chck);
    
    unsigned char digest[BUFFER];
    err += hash(digest, Y, t_s_chck, "0");

    if (bn_cmp(e_s, digest) == 0) {
        strcpy(client->tau_c, "1");
    }
    else {
        strcpy(client->tau_c, "0");
        return 0;
    }

    /*  t_s_chck, sk_i  →   SSAKA-DEVICE-PROOFVERIFY(t_s_chck, sk_i)
     *
     *  +++++++++++++++++++++
     *  ++++ DEVICE SIDE ++++
     *  +++++++++++++++++++++
     */

    struct DeviceProof devices[size];
    unsigned char t_i[size][BUFFER];
    unsigned char r_i[size][BUFFER];
    unsigned char *rnd = malloc(sizeof(unsigned int));
    for (int i = 0; i < size; i++) {
        err += random_str_num_in_range(rnd, G_MAXRANDOMNUMBER, G_MINRANDOMNUMBER);
        err += bn_mod(rnd, g_globals.g_q, r_i[i]);
        err += bn_modexp(g_globals.g_g, r_i[i], g_globals.g_q, t_i[i]);
        err += bn_modexp(t_s_chck, r_i[i], g_globals.g_q, devices[i].kappa_i);
    }

    /*                  ←   <kappa_i, t_i>
     *
     *  +++++++++++++++++++++
     *  ++++ CLIENT SIDE ++++
     *  +++++++++++++++++++++
     */

    err += random_str_num_in_range(rnd, G_MAXRANDOMNUMBER, G_MINRANDOMNUMBER);
    unsigned char r_0[BUFFER];
    err += bn_mod(rnd, g_globals.g_q, r_0);
    unsigned char t[BUFFER];
    err += bn_modexp(g_globals.g_g, r_0, g_globals.g_q, t);
    err += bn_modexp(t_s_chck, r_0, g_globals.g_q, client->kappa);
    for (int i = 0; i < size; i++) {
        err += bn_modmul(t, t_i[i], g_globals.g_q, t);
        err += bn_modmul(client->kappa, devices[i].kappa_i, g_globals.g_q, client->kappa);
    }

    err += hash(client->pi[0], Y, t, client->kappa);    //e_c

    /*  e_c             →   SSAKA-DEVICE-PROOFVERIFY
     *
     *  +++++++++++++++++++++
     *  ++++ DEVICE SIDE ++++
     *  +++++++++++++++++++++
     */

    unsigned char tmp_mul[BUFFER];
    unsigned char tmp_sub[BUFFER];
    for (int i = 0; i < size; i++) {
        err += bn_hashmul(client->pi[0], g_ssaka_deviceKeys[list_of_used_devs[i]].sk, tmp_mul);
        err += bn_sub("0", tmp_mul, tmp_mul);
        err += bn_add(r_i[i], tmp_mul, tmp_sub);
        err += bn_mod(tmp_sub, g_globals.g_q, devices[i].s_i);
    }

    /*                  ←   <device_i>
     *
     *  +++++++++++++++++++++
     *  ++++ CLIENT SIDE ++++
     *  +++++++++++++++++++++
     */

    err += bn_hashmul(client->pi[0], g_ssaka_deviceKeys[0].sk, tmp_mul);
    err += bn_sub("0", tmp_mul, tmp_mul);
    err += bn_add(r_i[0], tmp_mul, tmp_sub);
    err += bn_mod(tmp_sub, g_globals.g_q, client->pi[1]);

    for (int i = 0; i < size; i++) {
        err += bn_modadd(client->pi[1], devices[i].s_i, g_globals.g_q, client->pi[1]);
    }

    if(err != (13 + (11 * (size))))
        return 0;
    
    return 1;
}

/*  Support function definition
 *  print to console the keychain variables
 */
void _ssaka_keyPrinter(struct ssaka_Keychain *key) {
    printf("ID: %s\n", key->ID);
    printf("PK: %s\n", key->pk);
    printf("SK: %s\n", key->sk);

    return;
}