#include <SSAKA.h>

// definition of global values
//unsigned char g_g[BUFFER];
//unsigned int g_idCounter = 1;

struct aka_Keychain g_ssaka_serverKeys;
struct ssaka_Keychain g_ssaka_devicesKeys[G_NUMOFDEVICES];

struct paillierKeychain g_paiKeys = {{""}};
unsigned int currentNumberOfDevices = 4;
unsigned char pk_c[BUFFER];

// supportive functions declarations
void _ssaka_keyPrinter(struct ssaka_Keychain *key);
unsigned int _get_pk_c();

/* Generate spar = (G, g, q) from session key kappa → GENERATED BY CIPHER SUITE
    int aka_Setup (int kappa) {
        
        return 0;
    }
*/

/* Generate pk_c and sk_c from session key kappa → GENERATED BY CIPHER SUITE
    int aka_ClientRegister (int kappa) {
        
        return 0;
    }
*/

unsigned int ssaka_setup() {
    unsigned int err = 0;

    err += generate_keypair(&g_paiKeys);

    printf("---SERVER---\n");
    err += aka_initKeys(&g_ssaka_serverKeys);

    // pre-init of SSAKA keys for client and other devices
    for (int i = 0; i < currentNumberOfDevices; i++) {
        err += ssaka_KeyGeneration(&g_ssaka_devicesKeys[i]);
    }
    
    err += paiShamir_distribution(&g_paiKeys);
    err += _get_pk_c();

    printf("--- CLIENT ---\n");
    ssaka_keyPrinter(&g_ssaka_devicesKeys[0]);
    
    for (int j = 1; j < currentNumberOfDevices; j++) {
        printf("--- DEVICE %d ---\n", j);
        ssaka_keyPrinter(&g_ssaka_devicesKeys[j]);
    }

    if(err != 4 + currentNumberOfDevices)
        return 0;
    
    return 1;
}

unsigned int ssaka_KeyGeneration(struct ssaka_Keychain *keys) {
    keys->keys = malloc(sizeof(struct SchnorrKeychain));
    unsigned int err = random_str_num_in_range(keys->keys->pk, atoi(g_paiKeys.pk.n)-1, 1);
    sprintf(keys->ID, "%u", g_globals.idCounter++);

    return err;
}

unsigned int ssaka_ClientAddShare(unsigned int num_of_new_devices) {
    unsigned int err = 0;
    if(currentNumberOfDevices + num_of_new_devices > G_NUMOFDEVICES) {
        printf("Only %d places left!\n", G_NUMOFDEVICES-currentNumberOfDevices);
        return 2;
    }

    for (int i = 0; i < num_of_new_devices; i++) {
        err += ssaka_KeyGeneration(&g_ssaka_devicesKeys[currentNumberOfDevices+i]);
    }
    currentNumberOfDevices += num_of_new_devices;
    
    err += paiShamir_distribution(&g_paiKeys);
    err += _get_pk_c();

    if(err != 2 + num_of_new_devices)
        return 0;
    
    return 1;
}

unsigned int ssaka_ClientRevShare(unsigned int rev_devices_list[], unsigned int list_size) {
    int i = 0;
    unsigned int err = 0;
    if(currentNumberOfDevices - list_size < (G_POLYDEGREE+1)) {
        printf("Must remain at least %d devices!\n", G_POLYDEGREE+1);
        return 2;
    }

    for (i; i < list_size; i++) {
        if(rev_devices_list[i] == 0) {
            printf("Cannot remove client (0)!\n");
            return 3;
        }
        free(g_ssaka_devicesKeys[rev_devices_list[i]].keys);
        g_ssaka_devicesKeys[rev_devices_list[i]].keys = NULL;
    }

    unsigned int index_list_size = currentNumberOfDevices-list_size;
    unsigned int index_list[index_list_size];
    unsigned int counter = 0;
    for (i = 0; i < currentNumberOfDevices; i++) {
        if(g_ssaka_devicesKeys[i].keys != NULL) {
            index_list[counter++] = i;
        }
    }
    
    for(i = 0; i < currentNumberOfDevices; i++) {
        if(i < index_list_size) {
            strcpy(g_ssaka_devicesKeys[i].ID, g_ssaka_devicesKeys[index_list[i]].ID);
            g_ssaka_devicesKeys[i].keys = g_ssaka_devicesKeys[index_list[i]].keys;
            strcpy(g_ssaka_devicesKeys[i].kappa, g_ssaka_devicesKeys[index_list[i]].kappa);
        }
        else {
            g_ssaka_devicesKeys[i].ID[0] = '\0';
            g_ssaka_devicesKeys[i].keys = NULL;
            g_ssaka_devicesKeys[i].kappa[0] = '\0';
        }
    }

    currentNumberOfDevices -= list_size;
    err += paiShamir_distribution(&g_paiKeys);
    err += _get_pk_c();

    if(err != 2)
        return 0;
    
    return 1;
}

unsigned int ssaka_akaServerSignVerify(unsigned int list_of_used_devs[], unsigned int size, unsigned char * Y, struct ServerSign *server) {
    unsigned int err = 0;
    struct ClientProof client ={{""}};
    client.signature = malloc(sizeof(struct SchnorrSignature));
    struct SchnorrSignature signature = {{""}};

    if (strncmp(Y, "0", sizeof(Y)) == 0 || strncmp(g_ssaka_serverKeys.keys->sk, "0", sizeof(g_ssaka_serverKeys.keys->sk)) == 0 || strncmp(g_ssaka_devicesKeys[0].keys->pk, "0", sizeof(g_ssaka_devicesKeys[0].keys->pk)) == 0) {
        strcpy(server->tau_s, "0");
        printf("Y, SERVER sk or CLIENT pk == 0!\n");
        return 0;
    }

    err += schnorr_sign(g_globals.params, g_ssaka_serverKeys.keys->sk, Y, "0", &signature);

    /*  
     *  Server  →   (Y, sigma)      →   Client
     *         (aka_clientProofVerify)
     *  Server  ←   (tau_c, kappa)  ←   Client
     */
    err += ssaka_clientProofVerify(list_of_used_devs, size, Y, &signature, &client);
    if(strcmp(client.tau_c, "0") == 0) {
        strcpy(server->tau_s, "0");
        free(client.signature);
        return 0;
    }
    
    strcpy(server->kappa, "1");
    strcpy(client.signature->r, signature.r);
    unsigned char ver[BUFFER];
    sprintf(ver, "%d", schnorr_verify(g_globals.params, pk_c, Y, server->kappa, client.signature));
    strcpy(server->tau_s, ver);

    if(strcmp(server->kappa, client.kappa) == 0)
        printf(":)\n");
    
    free(client.signature);
    if (err != 2)
        return 0;
    return 1;
}


unsigned int ssaka_clientProofVerify(unsigned int list_of_used_devs[], unsigned int size, unsigned char *Y, struct SchnorrSignature *server_signature, struct ClientProof *client) {
    unsigned int err = 0;
    unsigned char ver[BUFFER];
    sprintf(ver, "%d", schnorr_verify(g_globals.params, g_ssaka_serverKeys.keys->pk, Y, "0", server_signature));
    strcpy(client->tau_c, ver);
    
    if (strcmp(client->tau_c, "0") == 0) {
        return 0;
    }

    /*  t_s_chck, sk_i  →   SSAKA-DEVICE-PROOFVERIFY(t_s_chck, sk_i)
     *
     *  +++++++++++++++++++++
     *  ++++ DEVICE SIDE ++++
     *  +++++++++++++++++++++
     */

    // for all devices except g_ssakadevicesKeys[0]! --> Client
    struct DeviceProof devices[size];
    unsigned char t_i[size][BUFFER];
    unsigned char r_i[size][BUFFER];
    for (int i = 0; i < size; i++) {
        err += random_str_num_in_range(r_i[i], atoi(g_globals.params->q), 1);
        err += bn_modexp(g_globals.params->g, r_i[i], g_globals.params->p, t_i[i]);
        err += bn_modexp(server_signature->c_prime, r_i[i], g_globals.params->p, devices[i].kappa_i);
    }

    /*                  ←   <kappa_i, t_i>
     *
     *  +++++++++++++++++++++
     *  ++++ CLIENT SIDE ++++
     *  +++++++++++++++++++++
     */

    unsigned char t[BUFFER];
    err += random_str_num_in_range(client->signature->r, atoi(g_globals.params->q), 1);
    err += bn_modexp(g_globals.params->g, client->signature->r, g_globals.params->p, t);
    err += bn_modexp(server_signature->c_prime, client->signature->r, g_globals.params->p, client->kappa);
    for (int i = 0; i < size; i++) {
        err += bn_modmul(t, t_i[i], g_globals.params->p, t);
        err += bn_modmul(client->kappa, devices[i].kappa_i, g_globals.params->p, client->kappa);
    }

    //printf("\n\nT: %s\nKAPPA: %s\n", t, client->kappa);

    err += hash(client->signature->hash, Y, t, client->kappa);    //e_c


    unsigned int interpolation_list[size+1];
    interpolation_list[size] = 0;
    for (int i = 0; i < size; i++) {
        interpolation_list[i] = list_of_used_devs[i];
    }

    /*  e_c             →   SSAKA-DEVICE-PROOFVERIFY
     *
     *  +++++++++++++++++++++
     *  ++++ DEVICE SIDE ++++
     *  +++++++++++++++++++++
     */
    

    unsigned char tmp_mul[BUFFER];
    unsigned char sk_i[BUFFER];
    for (int i = 0; i < size; i++) {
        err += part_interpolation(interpolation_list, size+1, i, sk_i);
        err += bn_modmul(client->signature->hash, sk_i, g_globals.params->q, tmp_mul);
        err += bn_modsub(r_i[i], tmp_mul, g_globals.params->q, devices[i].s_i);
    }

    /*                  ←   <device_i>
     *
     *  +++++++++++++++++++++
     *  ++++ CLIENT SIDE ++++
     *  +++++++++++++++++++++
     */

    unsigned char sk_0[BUFFER];
    err += part_interpolation(interpolation_list, size+1, size, sk_0);
    err += bn_modmul(client->signature->hash, sk_0, g_globals.params->q, tmp_mul);
    err += bn_modsub(client->signature->r, tmp_mul, g_globals.params->q, client->signature->signature);

    for (int i = 0; i < size; i++) {
        err += bn_modadd(client->signature->signature, devices[i].s_i, g_globals.params->q, client->signature->signature);
    }

    if(err != (7 + (9 * size)))
        return 0;
    
    return 1;
}

/*  Support function definition
 *  print to console the keychain variables
 */
void ssaka_keyPrinter(struct ssaka_Keychain *key) {
    printf("ID: %s\n", key->ID);
    printf("PK: %s\n", key->keys->pk);
    printf("SK: %s\n", key->keys->sk);

    return;
}

unsigned int _get_pk_c() {
    unsigned int err = 0;
    unsigned int interpolation_list[currentNumberOfDevices];
    for (int i = 0; i < currentNumberOfDevices; i++) {
        interpolation_list[i] = i;
    }
    err += paiShamir_interpolation(interpolation_list, currentNumberOfDevices, pk_c);
    err += bn_modexp(g_globals.params->g, pk_c, g_globals.params->p, pk_c);
    
    /* printf("PK: %s\n", pk_c); */

    if(err != 2)
        return 0;
    return 1;
}

void free_ssaka_mem() {
    free(g_globals.params);
    free(g_aka_serverKeys.keys);
    for (int i = 0; i < currentNumberOfDevices; i++) {
        free(g_ssaka_devicesKeys[i].keys);
    }

    return;
}