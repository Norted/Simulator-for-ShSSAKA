#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include "AKA.h"
//#include <gcrypt.h>

// supportive functions declarations
unsigned int hash(unsigned int Y, unsigned int sigma, unsigned int kappa);
void keyPrinter(struct Keychain keys);
struct Keychain initKeys();

/*  --- GLOBALS ---
 *  |-> g_q ................. order of multiplicative group Z*_q
 *  |-> g_g ................. generated generator from g_generators
 *  |-> g_generators ........ hardcoded generators of Z*_q
 *  |-> g_idCounter ......... helping couter for CID generation
 *  ------ support globals
 *      |-> g_generatosrLen ..... length of the g_generators field 
 *      |-> g_maxRandomNumber ... maximal random number
 *      |-> g_minRandomNumber ... minimal random number
 */
unsigned int g_q = 18;
unsigned int g_g;
unsigned int g_generators[6] = {4, 7, 9, 10, 13, 16};
unsigned int g_idCounter = 1;

int g_generatorsLen = 5;
int g_maxRandomNumber = 100;
int g_minRandomNumber = 1;

/*  --- MAIN FUNCTIONS ---  */

/* Generate spar = (G, g, q) from session key kappa → GENERATED BY CIPHER SUITE
    int aka_Setup (int kappa) {
        
        return 0;
    }
*/

/* Generate pk_c and sk_c from session key kappa → GENERATED BY CIPHER SUITE
    int aka_ClientRegister (int kappa) {
        
        return 0;
    }
*/

void aka_setup() {
    srand(3);
    g_g = g_generators[rand()%g_generatorsLen];
    
    printf("---CLIENT---\n");
    g_clientKeys = initKeys();
    printf("---SERVER---\n");
    g_serverKeys = initKeys();
    printf("\n");

    return;
}

struct ServerSign aka_serverSignVerify (unsigned int Y, unsigned int sk_s, unsigned int pk_c) {
    unsigned int sigma[2];
    struct ServerSign server;
    struct ClientProof client;

    unsigned int r_s = (rand() % (g_maxRandomNumber + 1 - g_minRandomNumber) + g_minRandomNumber)%g_q;
    unsigned int t_s = (unsigned int) pow((double) g_g, (double) r_s);
    
    sigma[0] = hash(Y, t_s, 0U);        //e_s
    sigma[1] = (r_s - sigma[0]*sk_s)%g_q; //s_s
    
    /*  
     *  Server  →   (Y, sigma)      →   Client
     *         (aka_clientProofVerify)
     *  Server  ←   (tau_c, kappa)  ←   Client
     */
    client = aka_clientProofVerify(Y, sigma, g_serverKeys.pk, g_clientKeys.sk);

    unsigned int t_chck = (unsigned int) pow((double) g_g, (double) client.pi[1]) * pow((double) pk_c, (double) client.pi[0]);
    server.kappa = (unsigned int) pow((double) t_chck, (double) r_s);
    
    if (client.pi[0] == hash(Y, t_chck, server.kappa)) {
        server.tau_s = 1;
    }
    else {
        server.tau_s = 0;
    }
     
    return server;
}

struct ClientProof aka_clientProofVerify (unsigned int Y, unsigned int sigma[2], unsigned int pk_s, unsigned int sk_c) {
    struct ClientProof client;
    unsigned int t_s_chck = (unsigned int) pow((double) g_g, (double) sigma[1]) * (unsigned int) pow((double) pk_s, (double) sigma[0]);
    
    if (sigma[0] == hash(Y, t_s_chck, 0U)) {
        client.tau_c = 1;
    }
    else {
        client.tau_c = 0;
        return client;
    }

    unsigned int r_c = (rand() % (g_maxRandomNumber + 1 - g_minRandomNumber) + g_minRandomNumber)%g_q;
    unsigned int t = (unsigned int) pow((double) g_g, (double) r_c);

    client.kappa = (unsigned int) pow((double) t_s_chck, (double) r_c);
    client.pi[0] = hash(Y, t, client.kappa);        //e_c
    client.pi[1] = (r_c - client.pi[0] * sk_c)%g_q;   //s_c

    return client;
}


/*  --- SUPPORT FUNCTIONS ---   */

// print to console the keychain variables
void keyPrinter(struct Keychain keys) {
    printf("ID: %u\n", keys.ID);
    printf("PK: %u\n", keys.pk);
    printf("SK: %u\n", keys.sk);
    
    return;
}

// initialize the keychain with computed values
struct Keychain initKeys() {
    struct Keychain keys;
    keys.sk = (unsigned int) (rand() % (g_maxRandomNumber + 1 - g_minRandomNumber) + g_minRandomNumber)%g_q;
    keys.pk = (unsigned int) pow((double) g_g, (double) keys.sk);
    keys.ID = g_idCounter++;
    
    keyPrinter(keys);
    return keys;
}

// momentally used instead of chosen hash from suite
unsigned int hash(unsigned int Y, unsigned int t_s, unsigned int kappa) {
    return (unsigned int) ((Y * pow(10, (double) log10(t_s)+1) + t_s)*pow(10, (double) log10(kappa)+1))%g_q;
}
