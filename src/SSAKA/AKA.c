#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include "AKA.h"
// #include <gcrypt.h>

// function declarations
unsigned int hash(unsigned int Y, unsigned int sigma, unsigned int kappa);
void key_printer(struct KEYCHAIN keys);
struct KEYCHAIN init_keys();

// globals
unsigned int Q = 18;
unsigned int G;
unsigned int GENERATORS[6] = {4, 7, 9, 10, 13, 16};
unsigned int ID_COUNTER = 1;

struct KEYCHAIN CLIENT_KEYS;
struct KEYCHAIN SERVER_KEYS;

int generators_len = 5;
int max_number = 100;
int minimum_number = 1;

/////////////////////////////////////////////////////////////////////
// MAIN FUNCTIONS ///////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

// Generate spar = (G, g, q) from session key kappa → GENERATED BY CIPHER SUITE
/*
    int SETUP (int kappa) {
        
        return 0;
    }
*/

// Generate pk_c and sk_c from session key kappa → GENERATED BY CIPHER SUITE
/*
    int CLIENT_REGISTER (int kappa) {
        
        return 0;
    }
*/

void aka_setup() {
    srand(3);
    G = GENERATORS[rand()%generators_len];
    
    printf("---CLIENT---\n");
    CLIENT_KEYS = init_keys();
    printf("---SERVER---\n");
    SERVER_KEYS = init_keys();
    printf("\n");

    return;
}

struct SERVER_SIGN aka_server_signverify (unsigned int Y, unsigned int sk_s, unsigned int pk_c) {
    unsigned int sigma[2];
    struct SERVER_SIGN server;
    struct CLIENT_PROOF client;

    unsigned int r_s = (rand() % (max_number + 1 - minimum_number) + minimum_number)%Q;
    unsigned int t_s = (unsigned int) pow((double) G, (double) r_s);
    
    sigma[0] = hash(Y, t_s, 0U);        //e_s
    sigma[1] = (r_s - sigma[0]*sk_s)%Q; //s_s
    
    client = aka_client_proofverify(Y, sigma, SERVER_KEYS.pk, CLIENT_KEYS.sk);

    unsigned int t_chck = (unsigned int) pow((double) G, (double) client.pi[1]) * pow((double) pk_c, (double) client.pi[0]);
    server.kappa = (unsigned int) pow((double) t_chck, (double) r_s);
    
    if (client.pi[0] == hash(Y, t_chck, server.kappa)) {
        server.tau_s = 1;
    }
    else {
        server.tau_s = 0;
    }
     
    return server;
}

struct CLIENT_PROOF aka_client_proofverify (unsigned int Y, unsigned int sigma[2], unsigned int pk_s, unsigned int sk_c) {
    struct CLIENT_PROOF client;
    unsigned int t_s_chck = (unsigned int) pow((double) G, (double) sigma[1]) * (unsigned int) pow((double) pk_s, (double) sigma[0]);
    
    if (sigma[0] == hash(Y, t_s_chck, 0U)) {
        client.tau_c = 1;
    }
    else {
        client.tau_c = 0;
        return client;
    }

    unsigned int r_c = (rand() % (max_number + 1 - minimum_number) + minimum_number)%Q;
    unsigned int t = (unsigned int) pow((double) G, (double) r_c);

    client.kappa = (unsigned int) pow((double) t_s_chck, (double) r_c);
    client.pi[0] = hash(Y, t, client.kappa);        //e_c
    client.pi[1] = (r_c - client.pi[0] * sk_c)%Q;   //s_c

    return client;
}


/////////////////////////////////////////////////////////////////////
// SUPPORT FUNCTIONS ////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

// print to console the keychain variables
void key_printer(struct KEYCHAIN keys) {
    printf("ID: %u\n", keys.ID);
    printf("PK: %u\n", keys.pk);
    printf("SK: %u\n", keys.sk);
    
    return;
}

// initialize the keychain with computed values
struct KEYCHAIN init_keys() {
    struct KEYCHAIN keys;
    keys.sk = (unsigned int) (rand() % (max_number + 1 - minimum_number) + minimum_number)%Q;
    keys.pk = (unsigned int) pow((double) G, (double) keys.sk);
    keys.ID = ID_COUNTER++;
    
    key_printer(keys);
    return keys;
}

// momentally used instead of chosen hash from suite
unsigned int hash(unsigned int Y, unsigned int t_s, unsigned int kappa) {
    return (unsigned int) ((Y * pow(10, (double) log10(t_s)+1) + t_s)*pow(10, (double) log10(kappa)+1))%Q;
}